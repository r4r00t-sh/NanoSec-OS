/*
 * NanoSec OS - VESA Framebuffer Driver
 * =====================================
 * Uses GRUB multiboot framebuffer for higher resolution
 * Default: 800x600x32bit
 */

#include "../kernel.h"

/* Framebuffer information from multiboot */
static uint32_t *framebuffer = NULL;
static uint32_t fb_width = 800;
static uint32_t fb_height = 600;
static uint32_t fb_pitch = 0;
static uint32_t fb_bpp = 32;
static int vesa_mode_active = 0;

/* Forward declaration */
void vesa_clear(uint32_t color);

/* Multiboot info structure (partial) */
typedef struct {
  uint32_t flags;
  uint32_t mem_lower;
  uint32_t mem_upper;
  uint32_t boot_device;
  uint32_t cmdline;
  uint32_t mods_count;
  uint32_t mods_addr;
  uint32_t syms[4];
  uint32_t mmap_length;
  uint32_t mmap_addr;
  uint32_t drives_length;
  uint32_t drives_addr;
  uint32_t config_table;
  uint32_t boot_loader_name;
  uint32_t apm_table;
  uint32_t vbe_control_info;
  uint32_t vbe_mode_info;
  uint16_t vbe_mode;
  uint16_t vbe_interface_seg;
  uint16_t vbe_interface_off;
  uint16_t vbe_interface_len;
  uint64_t framebuffer_addr;
  uint32_t framebuffer_pitch;
  uint32_t framebuffer_width;
  uint32_t framebuffer_height;
  uint8_t framebuffer_bpp;
  uint8_t framebuffer_type;
} __attribute__((packed)) multiboot_info_t;

/* Saved multiboot info */
static multiboot_info_t *mb_info = NULL;

/*
 * Initialize VESA framebuffer from multiboot info
 */
int vesa_init(uint32_t magic, uint32_t *mb_info_ptr) {
  /* Check multiboot magic */
  if (magic != 0x2BADB002) {
    return -1; /* Not booted by multiboot */
  }

  mb_info = (multiboot_info_t *)mb_info_ptr;

  /* Check if framebuffer info is available (bit 12) */
  if (!(mb_info->flags & (1 << 12))) {
    return -1; /* No framebuffer */
  }

  /* Get framebuffer info */
  framebuffer = (uint32_t *)(uintptr_t)mb_info->framebuffer_addr;
  fb_width = mb_info->framebuffer_width;
  fb_height = mb_info->framebuffer_height;
  fb_pitch = mb_info->framebuffer_pitch;
  fb_bpp = mb_info->framebuffer_bpp;

  vesa_mode_active = 1;

  /* Clear screen to dark blue */
  vesa_clear(0x001428);

  return 0;
}

/*
 * Check if VESA mode is active
 */
int vesa_is_active(void) { return vesa_mode_active; }

/*
 * Get screen dimensions
 */
void vesa_get_dimensions(uint32_t *width, uint32_t *height) {
  if (width)
    *width = fb_width;
  if (height)
    *height = fb_height;
}

/*
 * Clear screen with color
 */
void vesa_clear(uint32_t color) {
  if (!vesa_mode_active)
    return;

  for (uint32_t y = 0; y < fb_height; y++) {
    uint32_t *row = (uint32_t *)((uint8_t *)framebuffer + y * fb_pitch);
    for (uint32_t x = 0; x < fb_width; x++) {
      row[x] = color;
    }
  }
}

/*
 * Put pixel at (x, y) with 32-bit color
 */
void vesa_put_pixel(int x, int y, uint32_t color) {
  if (!vesa_mode_active)
    return;
  if (x < 0 || x >= (int)fb_width || y < 0 || y >= (int)fb_height)
    return;

  uint32_t *row = (uint32_t *)((uint8_t *)framebuffer + y * fb_pitch);
  row[x] = color;
}

/*
 * Get pixel color
 */
uint32_t vesa_get_pixel(int x, int y) {
  if (!vesa_mode_active)
    return 0;
  if (x < 0 || x >= (int)fb_width || y < 0 || y >= (int)fb_height)
    return 0;

  uint32_t *row = (uint32_t *)((uint8_t *)framebuffer + y * fb_pitch);
  return row[x];
}

/*
 * Draw horizontal line (fast)
 */
void vesa_hline(int x, int y, int len, uint32_t color) {
  if (!vesa_mode_active)
    return;
  if (y < 0 || y >= (int)fb_height)
    return;
  if (x < 0) {
    len += x;
    x = 0;
  }
  if (x + len > (int)fb_width)
    len = fb_width - x;
  if (len <= 0)
    return;

  uint32_t *row = (uint32_t *)((uint8_t *)framebuffer + y * fb_pitch);
  for (int i = 0; i < len; i++) {
    row[x + i] = color;
  }
}

/*
 * Draw vertical line
 */
void vesa_vline(int x, int y, int len, uint32_t color) {
  for (int i = 0; i < len; i++) {
    vesa_put_pixel(x, y + i, color);
  }
}

/*
 * Draw line (Bresenham)
 */
void vesa_line(int x0, int y0, int x1, int y1, uint32_t color) {
  int dx = (x1 > x0) ? (x1 - x0) : (x0 - x1);
  int dy = (y1 > y0) ? (y1 - y0) : (y0 - y1);
  int sx = (x0 < x1) ? 1 : -1;
  int sy = (y0 < y1) ? 1 : -1;
  int err = dx - dy;

  while (1) {
    vesa_put_pixel(x0, y0, color);
    if (x0 == x1 && y0 == y1)
      break;
    int e2 = 2 * err;
    if (e2 > -dy) {
      err -= dy;
      x0 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y0 += sy;
    }
  }
}

/*
 * Draw rectangle outline
 */
void vesa_rect(int x, int y, int w, int h, uint32_t color) {
  vesa_hline(x, y, w, color);
  vesa_hline(x, y + h - 1, w, color);
  vesa_vline(x, y, h, color);
  vesa_vline(x + w - 1, y, h, color);
}

/*
 * Fill rectangle
 */
void vesa_fill_rect(int x, int y, int w, int h, uint32_t color) {
  for (int i = 0; i < h; i++) {
    vesa_hline(x, y + i, w, color);
  }
}

/*
 * 8x8 bitmap font for ASCII 32-127 (simpler, faster)
 */
static const uint8_t vesa_font[96][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* Space */
    {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00}, /* ! */
    {0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* " */
    {0x6C, 0xFE, 0x6C, 0x6C, 0xFE, 0x6C, 0x00, 0x00}, /* # */
    {0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00}, /* $ */
    {0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00, 0x00}, /* % */
    {0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00}, /* & */
    {0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00}, /* ' */
    {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00}, /* ( */
    {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00}, /* ) */
    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}, /* * */
    {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00}, /* + */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30}, /* , */
    {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00}, /* - */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00}, /* . */
    {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x00, 0x00}, /* / */
    {0x7C, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0x7C, 0x00}, /* 0 */
    {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}, /* 1 */
    {0x7C, 0xC6, 0x06, 0x1C, 0x30, 0x66, 0xFE, 0x00}, /* 2 */
    {0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00}, /* 3 */
    {0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00}, /* 4 */
    {0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00}, /* 5 */
    {0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00}, /* 6 */
    {0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00}, /* 7 */
    {0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00}, /* 8 */
    {0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00}, /* 9 */
    {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00}, /* : */
    {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30}, /* ; */
    {0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00}, /* < */
    {0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00}, /* = */
    {0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00}, /* > */
    {0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00}, /* ? */
    {0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00}, /* @ */
    {0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00}, /* A */
    {0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00}, /* B */
    {0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00}, /* C */
    {0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00}, /* D */
    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00}, /* E */
    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00}, /* F */
    {0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3A, 0x00}, /* G */
    {0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00}, /* H */
    {0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, /* I */
    {0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00}, /* J */
    {0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00}, /* K */
    {0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00}, /* L */
    {0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00}, /* M */
    {0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00}, /* N */
    {0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00}, /* O */
    {0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00}, /* P */
    {0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0x7C, 0x0E, 0x00}, /* Q */
    {0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00}, /* R */
    {0x7C, 0xC6, 0xE0, 0x7C, 0x0E, 0xC6, 0x7C, 0x00}, /* S */
    {0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, /* T */
    {0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00}, /* U */
    {0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00}, /* V */
    {0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00}, /* W */
    {0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00}, /* X */
    {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00}, /* Y */
    {0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00}, /* Z */
    {0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00}, /* [ */
    {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00}, /* \ */
    {0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00}, /* ] */
    {0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00}, /* ^ */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}, /* _ */
    {0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00}, /* ` */
    {0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00}, /* a */
    {0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00}, /* b */
    {0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00}, /* c */
    {0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00}, /* d */
    {0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00}, /* e */
    {0x3C, 0x66, 0x60, 0xF8, 0x60, 0x60, 0xF0, 0x00}, /* f */
    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x78}, /* g */
    {0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00}, /* h */
    {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00}, /* i */
    {0x06, 0x00, 0x0E, 0x06, 0x06, 0x66, 0x66, 0x3C}, /* j */
    {0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00}, /* k */
    {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, /* l */
    {0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0x00}, /* m */
    {0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x00}, /* n */
    {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00}, /* o */
    {0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0}, /* p */
    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E}, /* q */
    {0x00, 0x00, 0xDC, 0x76, 0x60, 0x60, 0xF0, 0x00}, /* r */
    {0x00, 0x00, 0x7C, 0xC0, 0x7C, 0x06, 0xFC, 0x00}, /* s */
    {0x30, 0x30, 0xFC, 0x30, 0x30, 0x36, 0x1C, 0x00}, /* t */
    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00}, /* u */
    {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00}, /* v */
    {0x00, 0x00, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00}, /* w */
    {0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00}, /* x */
    {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x7C}, /* y */
    {0x00, 0x00, 0xFE, 0x8C, 0x18, 0x32, 0xFE, 0x00}, /* z */
    {0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00}, /* { */
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}, /* | */
    {0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00}, /* } */
    {0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* ~ */
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, /* DEL */
};

/*
 * Draw character at (x, y) - 8x8 font
 */
void vesa_draw_char(int x, int y, char c, uint32_t color) {
  if (c < 32 || c > 127)
    c = '?';
  int idx = c - 32;
  if (idx >= 96)
    idx = 0;

  const uint8_t *glyph = vesa_font[idx];

  for (int row = 0; row < 8; row++) {
    uint8_t bits = glyph[row];
    for (int col = 0; col < 8; col++) {
      if (bits & (0x80 >> col)) {
        vesa_put_pixel(x + col, y + row, color);
      }
    }
  }
}

/*
 * Draw string
 */
void vesa_draw_string(int x, int y, const char *str, uint32_t color) {
  while (*str) {
    vesa_draw_char(x, y, *str, color);
    x += 8;
    str++;
  }
}

/*
 * Make RGB color (0xRRGGBB)
 */
uint32_t vesa_rgb(uint8_t r, uint8_t g, uint8_t b) {
  return (r << 16) | (g << 8) | b;
}
